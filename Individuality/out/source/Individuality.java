/* autogenerated by Processing revision 1281 on 2022-03-31 */
import processing.core.*;
import processing.data.*;
import processing.event.*;
import processing.opengl.*;

import java.util.HashMap;
import java.util.ArrayList;
import java.io.File;
import java.io.BufferedReader;
import java.io.PrintWriter;
import java.io.InputStream;
import java.io.OutputStream;
import java.io.IOException;

public class Individuality extends PApplet {

Individual i0, i1;

 public void setup() {
  /* size commented out by preprocessor */;
  i0 = new Individual(true);
  i1 = new Individual(true);

  println(i0);
  println(i1);
}//setup

 public void draw() {
  background(255);

  i0.display(100, 100, false);
  i1.display(300, 100, true);
}//draw

 public void keyPressed() {
  if (key == 'p') {
    i0 = new Individual(true);
    i1 = new Individual(true);
  }
}//keyPressed
public class Gene {
    private int genotype[];
    private int offset;

    public Gene(int len, int offset) {
        this.offset = offset;
        genotype = new int[len];
        for (int i = 0; i < len; i++) genotype[i] = (int)random(0,2);
    }

    public Gene (Gene other) {
        genotype = new int[other.genotype.length];
        arrayCopy(genotype, other.genotype);
    }

    public int getValue() {
        int val = 0;
        for (int i = genotype.length - 1; i >= 0; i--) {
            val += genotype[i] * Math.pow(2,genotype.length - (i + 1));
        }
        return val + offset;
    }
     public void mutate() {
        int i = (int)random(0,genotype.length);
        genotype[i] = genotype[i] == 1 ? 0 : 1;
    }
     public String toString() {
        String val = "BE->";
        for (int i = 0; i < genotype.length; i++) {
            val += genotype[i];
        }
        val += " " + (getValue() + offset);
        return val;
    }
}
public enum GeneType {
    SIDES(0),
    RAD(1),
    SPIN_RATE(2),
    RED(3),
    BLUE(4),
    GREEN(5);

  private int pos;

  private GeneType(int pos) {
    this.pos = pos;
  }

  public int getPos() {
    return pos;
  }
}

public class Individual {

  Gene chromosome[];
  RegularGon phenotype;
  float fitness;

  public Individual(Boolean randInd) {
    chromosome = new Gene[6];

    if (randInd) {
      chromosome[GeneType.SIDES.getPos()] = new Gene((int)(log(32) / log(2)), 0);
      chromosome[GeneType.RAD.getPos()] = new Gene((int)(log(64) / log(2)), 0);
      chromosome[GeneType.SPIN_RATE.getPos()] = new Gene((int)(log(16) / log(2)), -7);
      chromosome[GeneType.RED.getPos()] = new Gene((int)(log(256) / log(2)), 0);
      chromosome[GeneType.BLUE.getPos()] = new Gene((int)(log(256) / log(2)), 0);
      chromosome[GeneType.GREEN.getPos()] = new Gene((int)(log(256) / log(2)), 0);
    }
    setPhenotype();
  }

   public void setPhenotype() {
    int c = color(chromosome[GeneType.RED.getPos()].getValue(), chromosome[GeneType.GREEN.getPos()].getValue(), chromosome[GeneType.BLUE.getPos()].getValue());
    phenotype = new RegularGon(chromosome[GeneType.SIDES.getPos()].getValue(), chromosome[GeneType.RAD.getPos()].getValue() / 2,
      chromosome[GeneType.SPIN_RATE.getPos()].getValue(), c);
  }

   public void mutate(float rate) {
    for (int i = 0; i < chromosome.length; i++) {
      if (random(1) < rate) {
        chromosome[i].mutate();
      }
    }
    setPhenotype();
  }

   public String toString() {
    String res = "";
    for (Gene i : chromosome) {
      res += i.toString() + '\n';
    }
    return res;
  }

   public void display(int x, int y, boolean showFitness) {
    phenotype.display(x, y);
    if (showFitness) {
      text(fitness, x, y);
    }
  }
}
class PathShape {

  int MAX_RANDOM_POINTS = 10;
  //x, y point lists
  IntList xs;
  IntList ys;
  //bounding box for the shape
  int topY;
  int leftX;
  int shapeWidth;
  int shapeHeight;

  int centroid[];
  float area;
  float rotationSpeed;
  float displayAngle;

  int inside;
  int border;

  PathShape() {
    xs = new IntList();
    ys = new IntList();
    inside = color(PApplet.parseInt(random(256)), PApplet.parseInt(random(256)), PApplet.parseInt(random(256)));
    border = color(0);
    centroid = new int[2];
    area = 0;
    topY = 0;
    leftX = 0;
    shapeWidth = width;
    shapeHeight = height;
    rotationSpeed = 0;
    displayAngle = 0;
  }//constructor

  PathShape(int lx, int ty, int sw, int sh) {
    this();
    leftX = lx;
    topY = ty;
    shapeWidth = sw;
    shapeHeight = sh;
  }

   public void randomize() {
    xs.clear();
    ys.clear();
    int right_x = leftX + shapeWidth;
    int bottom_y = topY + shapeHeight;
    int numPoints = PApplet.parseInt(random(3, MAX_RANDOM_POINTS+1));
    for (int s=0; s < numPoints; s++) {
      int x = PApplet.parseInt(random(leftX, right_x));
      int y = PApplet.parseInt(random(topY, bottom_y));
      addPoint(x, y);
    }
  }//random PathShape

   public boolean isValid() {
    int right_x = leftX + shapeWidth;
    int bottom_y = topY + shapeHeight;
    boolean valid =  centroid[0] > leftX && centroid[0] < right_x;
    valid = valid && centroid[1] > topY && centroid[1] < bottom_y;
    return valid;
  }//isValid

   public void display() {

    stroke(border);
    fill(inside);
    beginShape();
    for ( int i = 0; i < xs.size(); i++ )
      vertex( xs.get(i), ys.get(i) );
    endShape(CLOSE);
    noStroke();
    fill(0, 0, 255);
    circle(centroid[0], centroid[1], 5);

  }//display

   public void display(int x, int y) {

    stroke(border);
    fill(inside);

    pushMatrix();
    translate(x, y);
    displayAngle+= rotationSpeed;
    rotate(radians(displayAngle));

    beginShape();
    for ( int i = 0; i < xs.size(); i++ )
      vertex( xs.get(i), ys.get(i) );
    endShape(CLOSE);
    noStroke();
    fill(0, 0, 255);
    circle(centroid[0], centroid[1], 5);
    popMatrix();
  }//display


   public void setCentroid() {
    int sumX = 0;
    int sumY = 0;
    for (int i=0; i < xs.size(); i++ ) {
      int p0,p1;
      p0=i;
      if (i == xs.size()-1) {
        p1 = 0;
      }
      else {
        p1 = i+1;
      }
      sumX += (xs.get(p0) + xs.get(p1)) * ((xs.get(p0) * ys.get(p1)) - (xs.get(p1) * ys.get(p0)));
      sumY += (ys.get(p0) + ys.get(p1)) * ((xs.get(p0) * ys.get(p1)) - (xs.get(p1) * ys.get(p0)));
    }
    setArea();
    centroid[0] = PApplet.parseInt( (1 / (6 * area)) * sumX );
    centroid[1] = PApplet.parseInt( (1 / (6 * area)) * sumY );
  }//setCent

   public void setArea() {
    area = 0;
    for ( int i=0; i < xs.size(); i++) {
      int p0, p1;
      p0 = i;
      if (i == xs.size()-1) {
        p1 = 0;
      }
      else {
        p1 = i+1;
      }
      area += (xs.get(p0) * ys.get(p1)) - (xs.get(p1) * ys.get(p0));
    }
    area = area * 0.5f;
  }//setArea

   public void addPoint(int x, int y) {
    xs.append(x);
    ys.append(y);

    setCentroid();
  }//addPoint


}//class PathShape
class RegularGon extends PathShape {
  int MAX_SIDES = 20;
  int numSides;
  int gonLength;

  //RegularGon(int lx, int ty, int sw) {
  //  super(lx, ty, sw, sw);
  //  numSides = 0;
  //  gonLength = 0;
  //}

  RegularGon(int cx, int cy, int sides, int length) {
    centroid[0] = cx;
    centroid[1] = cy;
    numSides = sides;
    gonLength = length;
    leftX = centroid[0] - gonLength;
    topY = centroid[1] - gonLength;
    shapeWidth = gonLength;
    shapeHeight = gonLength;

    generateRegularPolygon();
  }//PathShape

  RegularGon(int sides, int length, float rSpeed, int c) {
    this(0, 0, sides, length);
    rotationSpeed = rSpeed;
    inside = c;
  }//PathShape

   public boolean isValid() {
    return xs.size() > 0;
  }//isValid

   public void randomize() {
    centroid[0] = leftX + shapeWidth/2;
    centroid[1] = topY+ shapeHeight/2;
    numSides = PApplet.parseInt(random(3, MAX_SIDES+1));

    gonLength = PApplet.parseInt(random(5, shapeWidth/2));
    generateRegularPolygon();
  }

   public void generateRegularPolygon() {
    if (numSides > 0) {
      float theta = radians(360 / numSides);
      for (int n=0; n < numSides; n++) {
        int x = PApplet.parseInt(gonLength * cos(n * theta)) + centroid[0];
        int y = PApplet.parseInt(gonLength * sin(n * theta)) + centroid[1];
        xs.append(x);
        ys.append(y);
      }
    }
  }//generateRegularPolygon

}//RegularGon


  public void settings() { size(800, 800); }

  static public void main(String[] passedArgs) {
    String[] appletArgs = new String[] { "Individuality" };
    if (passedArgs != null) {
      PApplet.main(concat(appletArgs, passedArgs));
    } else {
      PApplet.main(appletArgs);
    }
  }
}
